<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="./lottie.js"></script>
  <title>lottie教程</title>
  <style>
    * {
      font-size: 2vmin;
      margin: 0;
      padding: 0;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100vh;
      background-color: #f7f7f7;
      overflow: hidden;
    }

    #container {
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100vh;
      background-color: #171717;
    }

    .container_hidden {
      /*  
        translateY(100%) 向下移动100%的距离，也就是隐藏起来
        这里的100%是相对于父元素的高度，也就是整个body的高度
        所以当动画播放完毕后，整个body的高度会变成动画高度，也就是动画的高度，然后再隐藏起来
      */
      transform: translateY(100%);
      /*  
        visibility: hidden; 隐藏元素
        visibility: visible; 显示元素
        这里的hidden是隐藏整个动画容器，也就是整个lottie动画，而不是隐藏动画的某个元素
      */
      visibility: hidden;

      transition: 0.8s ease;
    }

    #animation_box {
      position: relative;
      width: 50rem;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="animation_box"></div>
  </div>
</body>
<script>
  var ani = bodymovin.loadAnimation({
    // 容器
    container: document.getElementById('animation_box'), // Required
    renderer: 'svg',
    // 动画数据
    path: 'welcome.json', // Required 
    // 循环播放
    loop: false, // Optional
    // 自动播放
    autoplay: true, // Optional
    // 名称
    name: "Hello World", // Name for future reference. Optional.
  })

  document.getElementById('animation_box').addEventListener('click', function () {
    // 停止播放 效果直接消失
    // ani.stop()
    // 暂停
    // ani.pause()

    // 到60帧暂停
    // ani.goToAndStop(60)

    // 到60帧开始执行
    ani.goToAndPlay(60)


  })


  // // 根据鼠标滚动进行操控svg动画 
  //  改为 autoplay: false, // Optional
  // 这里不用【wheel】原因是，他是在可以滚动的区域才会执行。
  // 而 wheel 他是根据鼠标滚动的距离来判断的，如果距离很小，他就不会执行。
  // let frame = 0
  // window.addEventListener('wheel', () => {
  //   if (event.wheelDelta < 0) {
  //     frame += 20
  //   }
  //   else {
  //     frame -= 20
  //   }
  //   ani.goToAndStop(frame)
  // })

  let readystate = 0;
  /**
   * 监听动画播放事件【每更新一帧就会触发该函数，即只要动画在执行，就不会停止执行该方法】
   */
  ani.addEventListener('enterFrame', () => {
    if (ani.currentFrame >= 65) {
      if (readystate == 0) {
        // 继续从第0帧开始执行，因为现在页面还没加载完毕
        ani.goToAndPlay(0)
      }
    }
  })

  // 模拟网络请求
  setTimeout(() => {
    readystate = 1
  }, 5000)

  /**
   * 监听动画播放完毕事件
  */
  ani.addEventListener('complete', () => {
    // 动画播放完毕后，隐藏动画容器
    document.getElementById('container').classList.add('container_hidden')
  })
</script>

</html>